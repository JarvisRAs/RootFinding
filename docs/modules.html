
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Modules &#8212; YRoots  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Glossary of Methods" href="genindex.html" />
    <link rel="prev" title="YRoots" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="modules">
<span id="id1"></span><h1>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<div class="section" id="module-yroots.subdivision">
<span id="subdivision"></span><h2>Subdivision<a class="headerlink" href="#module-yroots.subdivision" title="Permalink to this headline">¶</a></h2>
<p>Subdivision provides a solve function that finds roots of a set of functions
by approximating the functions with Chebyshev polynomials.
When the approximation is performed on a sufficiently small interval,
the approximation degree is small enough to be solved efficiently.</p>
<dl class="class">
<dt id="yroots.subdivision.Memoize">
<em class="property">class </em><code class="descclassname">yroots.subdivision.</code><code class="descname">Memoize</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.Memoize" title="Permalink to this definition">¶</a></dt>
<dd><p>A Memoization class taken from Stack Overflow
<a class="reference external" href="https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python">https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python</a></p>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.chebyshev_block_copy">
<code class="descclassname">yroots.subdivision.</code><code class="descname">chebyshev_block_copy</code><span class="sig-paren">(</span><em>values_block</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.chebyshev_block_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function helps avoid double evaluation of functions at
interpolation points. It takes in a tensor of function evaluation values
and copies these values to a new tensor appropriately to prepare for
chebyshev interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>values_block</strong> (<em>numpy array</em>) – A block of values from function evaluation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values_cheb</strong> – Chebyshev interpolation values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.full_cheb_approximate">
<code class="descclassname">yroots.subdivision.</code><code class="descname">full_cheb_approximate</code><span class="sig-paren">(</span><em>f</em>, <em>a</em>, <em>b</em>, <em>deg</em>, <em>tol</em>, <em>good_deg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.full_cheb_approximate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the full chebyshev approximation and checks if it’s good enough.</p>
<p>Called recursively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>function</em>) – The function we approximate.</p></li>
<li><p><strong>a</strong> (<em>numpy array</em>) – The lower bound(s) on the interval.</p></li>
<li><p><strong>b</strong> (<em>numpy array</em>) – The upper bound(s) on the interval.</p></li>
<li><p><strong>deg</strong> (<em>int</em>) – The degree to approximate with.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – How small the high degree terms must be to consider the approximation
accurate.</p></li>
<li><p><strong>good_deg</strong> (<em>numpy array</em>) – Interpoation degree that is guaranteed to give an approximation valid
to within approx_tol.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>coeff</strong> (<em>numpy array</em>) – The coefficient array of the interpolation. If it can’t get a good
approximation and needs to subdivide, returns None.</p></li>
<li><p><strong>bools</strong> (<em>numpy array</em>) – (2^n, 1) array of bools corresponding to which subintervals the function
changes sign in.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.get_subintervals">
<code class="descclassname">yroots.subdivision.</code><code class="descname">get_subintervals</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>dimensions</em>, <em>interval_data</em>, <em>polys</em>, <em>change_sign</em>, <em>approx_tol</em>, <em>check_subintervals=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.get_subintervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the subintervals to divide a search interval into.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>numpy array</em>) – The lower bound on the interval.</p></li>
<li><p><strong>b</strong> (<em>numpy array</em>) – The upper bound on the interval.</p></li>
<li><p><strong>dimensions</strong> (<em>numpy array</em>) – The dimensions we want to cut in half.</p></li>
<li><p><strong>interval_data</strong> (<a class="reference internal" href="#yroots.IntervalChecks.IntervalData" title="yroots.IntervalChecks.IntervalData"><em>IntervalData</em></a>) – A class to run the subinterval checks and keep track of the
solve progress</p></li>
<li><p><strong>polys</strong> (<em>list MultiCheb polynomials</em>) – A list of MultiCheb polynomials representing the function
approximations on the interval to subdivide.
Used in the subinterval checks.</p></li>
<li><p><strong>change_sign</strong> (<em>list of bools</em>) – A list of bools of whether we know the functions can change sign
on the subintervals. Used in the subinterval checks.</p></li>
<li><p><strong>approx_tol</strong> (<em>float</em>) – <p>The bound of the sup norm error of the chebyshev approximation.
Because trim_coeff introduces this much error again, 2*approx_tol</p>
<blockquote>
<div><p>is passed into the subintervals checks.</p>
</div></blockquote>
</p></li>
<li><p><strong>check_subintervals</strong> (<em>bool</em>) – If True runs the subinterval checks to throw out intervals where
the functions are never 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>subintervals</strong> – Each element of the list is a tuple containing an a and b,
the lower and upper bounds of the interval.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of tuples</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.good_direc">
<code class="descclassname">yroots.subdivision.</code><code class="descname">good_direc</code><span class="sig-paren">(</span><em>coeffs</em>, <em>dim</em>, <em>solve_tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.good_direc" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if this is a good direction to try solving with division.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeffs</strong> (<em>list</em>) – The coefficient matrices of the polynomials to solve.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The direction to divide by in division.</p></li>
<li><p><strong>solve_tol</strong> (<em>float</em>) – How small spots in the Macaulay diagonal are allowed to get before we
determine it is unstable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>good_direc</strong> – If True running division should be stable. If False, probably not.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.good_zeros_1d">
<code class="descclassname">yroots.subdivision.</code><code class="descname">good_zeros_1d</code><span class="sig-paren">(</span><em>zeros</em>, <em>imag_tol=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.good_zeros_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the real zeros in the interval [-1,1] in the one dimensional case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeros</strong> (<em>numpy array</em>) – The zeros to be checked.</p></li>
<li><p><strong>imag_tol</strong> (<em>float</em>) – How large the imaginary part can be to still have it be considered real.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>good_zeros</strong> – The real zero in [-1,1] of the input zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.good_zeros_nd">
<code class="descclassname">yroots.subdivision.</code><code class="descname">good_zeros_nd</code><span class="sig-paren">(</span><em>zeros</em>, <em>imag_tol=1e-05</em>, <em>real_tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.good_zeros_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the real zeros in the -1 to 1 interval in each dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeros</strong> (<em>numpy array</em>) – The zeros to be checked.</p></li>
<li><p><strong>imag_tol</strong> (<em>float</em>) – How large the imaginary part can be to have it be considered real.</p></li>
<li><p><strong>real_tol</strong> (<em>float</em>) – How far the real part can be outside the interval [-1,1] and still be
considered valid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>good_zeros</strong> – The real zeros in [-1,1] of the input zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.interval_approximate_1d">
<code class="descclassname">yroots.subdivision.</code><code class="descname">interval_approximate_1d</code><span class="sig-paren">(</span><em>f</em>, <em>a</em>, <em>b</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.interval_approximate_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the chebyshev approximation of a one-dimensional function
on an interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>function from R -&gt; R</em>) – The function to interpolate.</p></li>
<li><p><strong>a</strong> (<em>float</em>) – The lower bound on the interval.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – The upper bound on the interval.</p></li>
<li><p><strong>deg</strong> (<em>int</em>) – The degree of the interpolation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coeffs</strong> – The coefficient of the chebyshev interpolating polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.interval_approximate_nd">
<code class="descclassname">yroots.subdivision.</code><code class="descname">interval_approximate_nd</code><span class="sig-paren">(</span><em>f</em>, <em>a</em>, <em>b</em>, <em>deg</em>, <em>return_bools=False</em>, <em>multiplier=None</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.interval_approximate_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the chebyshev approximation of an n-dimensional function
on an interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>function from R^n -&gt; R</em>) – The function to interpolate.</p></li>
<li><p><strong>a</strong> (<em>numpy array</em>) – The lower bound on the interval.</p></li>
<li><p><strong>b</strong> (<em>numpy array</em>) – The upper bound on the interval.</p></li>
<li><p><strong>deg</strong> (<em>numpy array</em>) – The degree of the interpolation in each dimension.</p></li>
<li><p><strong>return_bools</strong> (<em>bool</em>) – Whether to return bools that indicate if the funtion changes sign.</p></li>
<li><p><strong>multiplier</strong> (<em>float</em>) – The multiplier used to scale an interval during approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>coeffs</strong> (<em>numpy array</em>) – The coefficient of the chebyshev interpolating polynomial.</p></li>
<li><p><strong>multiplier</strong> (<em>float</em>) – Scaling factor to help scale up small values for precision.</p></li>
<li><p><strong>change_sign</strong> (<em>numpy array (Optional)</em>) – list of which subintervals change sign</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.mon_combos_limited">
<code class="descclassname">yroots.subdivision.</code><code class="descname">mon_combos_limited</code><span class="sig-paren">(</span><em>mon</em>, <em>remaining_degrees</em>, <em>shape</em>, <em>cur_dim=0</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.mon_combos_limited" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the monomials of a given degree that fits in a given shape and
returns them. Works recursively.</p>
<p>Very similar to mon_combos, but only returns the monomials of the desired degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon</strong> (<em>list</em>) – A list of zeros, the length of which is the dimension of the desired
monomials. Will change as the function searches recursively.</p></li>
<li><p><strong>remaining_degrees</strong> (<em>int</em>) – Initially the degree of the monomials desired. Will decrease as the
function searches recursively.</p></li>
<li><p><strong>shape</strong> (<em>tuple</em>) – The limiting shape. The i’th index of the mon can’t be bigger than the
i’th index of the shape.</p></li>
<li><p><strong>cur_dim</strong> (<em>int</em>) – The current position in the list the function is iterating through.
Defaults to 0, but increases in each step of the recursion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>answers</strong> – A list of all the monomials.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.polish_zeros">
<code class="descclassname">yroots.subdivision.</code><code class="descname">polish_zeros</code><span class="sig-paren">(</span><em>zeros</em>, <em>funcs</em>, <em>tol=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.polish_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Polishes the given zeros of the functions to a better accuracy.</p>
<p>Resolves with finer tolerances in a box around the zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeros</strong> (<em>numpy array</em>) – The given zeros.</p></li>
<li><p><strong>funcs</strong> (<em>list</em>) – The functions to find the zeros of.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – How big of a box around the found zeros to solve on.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>polish_zeros</strong> – The polished zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.solve">
<code class="descclassname">yroots.subdivision.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>funcs</em>, <em>a</em>, <em>b</em>, <em>plot=False</em>, <em>plot_intervals=False</em>, <em>polish=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the real roots of the given list of functions on a given interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>funcs</strong> (<em>list of vectorized</em><em>, </em><em>callable functions</em>) – Functions to find the common roots of.
More efficient if functions have an ‘evaluate_grid’ method handle
function evaluation on a grid of points.</p></li>
<li><p><strong>a</strong> (<em>numpy array</em>) – The lower bound(s) on the interval.</p></li>
<li><p><strong>b</strong> (<em>numpy array</em>) – The upper bound(s) on the interval.</p></li>
<li><p><strong>plot</strong> (<em>bool</em>) – If True plots the zeros-loci of the functions along with the
computed roots.</p></li>
<li><p><strong>plot_intervals</strong> (<em>bool</em>) – If True, plot is True, and the functions are 2 dimensional, plots what
check/method solved each part of the interval.</p></li>
<li><p><strong>polish</strong> (<em>bool</em>) – If True, resolves for each root on a smaller interval with a finer
approximation to give a more accurate answer.</p></li>
<li><p><strong>finding roots of a univariate function</strong><strong>, </strong><strong>funcs does not need to be</strong> (<em>If</em>) – </p></li>
<li><p><strong>list</strong><strong>, </strong><strong>and a and b can be floats instead of arrays.</strong> (<em>a</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zeros</strong> – The common zeros of the polynomials. Each row is a root.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This can be used to solve a system of two dimensional equations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">yroots</span> <span class="k">as</span> <span class="nn">yr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roots</span> <span class="o">=</span> <span class="n">yr</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">],</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roots</span>
<span class="go">array([[ 0.59192208, -0.97888622],</span>
<span class="gp">... </span>  <span class="p">[</span> <span class="mf">0.79322528</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7775749</span> <span class="p">],</span>
<span class="gp">... </span>  <span class="p">[</span> <span class="mf">0.98545828</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.58535726</span><span class="p">]])</span>
</pre></div>
</div>
<p>This can also be used to solve higher dimensional systems. For example,
we have a 3 dimensional system.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">yroots</span> <span class="k">as</span> <span class="nn">yr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roots</span> <span class="o">=</span> <span class="n">yr</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">h</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">polish</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Show the number of roots and maximal residuals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">roots</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]))),</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">roots</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]))),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
<span class="gp">... </span><span class="n">h</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">roots</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])))</span>
<span class="go">(6, 3.216245299353273e-16, 4.948322275872661e-15, 1.8096635301390052e-14)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.subdivision_solve_1d">
<code class="descclassname">yroots.subdivision.</code><code class="descname">subdivision_solve_1d</code><span class="sig-paren">(</span><em>f</em>, <em>a</em>, <em>b</em>, <em>interval_data</em>, <em>cheb_approx_tol=1e-05</em>, <em>max_degree=128</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.subdivision_solve_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the roots of a one-dimensional function using subdivision and chebyshev approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>function from R^n -&gt; R</em>) – The function to interpolate.</p></li>
<li><p><strong>a</strong> (<em>numpy array</em>) – The lower bound on the interval.</p></li>
<li><p><strong>b</strong> (<em>numpy array</em>) – The upper bound on the interval.</p></li>
<li><p><strong>cheb_approx_tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
<li><p><strong>max_degree</strong> (<em>int</em>) – The degree of the interpolation before subdividing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coeffs</strong> – The coefficient of the chebyshev interpolating polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.subdivision_solve_nd">
<code class="descclassname">yroots.subdivision.</code><code class="descname">subdivision_solve_nd</code><span class="sig-paren">(</span><em>funcs</em>, <em>a</em>, <em>b</em>, <em>deg</em>, <em>interval_data</em>, <em>approx_tol=0.0001</em>, <em>solve_tol=1e-08</em>, <em>polish=False</em>, <em>good_degs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.subdivision_solve_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the common zeros of the given functions for multidimensional
systems.
# TODO Long Function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>funcs</strong> (<em>list</em>) – Each element of the list is a callable function.</p></li>
<li><p><strong>a</strong> (<em>numpy array</em>) – The lower bound on the interval.</p></li>
<li><p><strong>b</strong> (<em>numpy array</em>) – The upper bound on the interval.</p></li>
<li><p><strong>deg</strong> (<em>int</em>) – The degree to approximate with in the chebyshev approximation.</p></li>
<li><p><strong>interval_data</strong> (<a class="reference internal" href="#yroots.IntervalChecks.IntervalData" title="yroots.IntervalChecks.IntervalData"><em>IntervalData</em></a>) – A class to run the subinterval checks and keep track of the solve progress</p></li>
<li><p><strong>approx_tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
<li><p><strong>solve_tol</strong> (<em>float</em>) – The tolerance to pass into division solve.</p></li>
<li><p><strong>polish</strong> (<em>bool</em>) – If True resolves for each root on a smaller interval with a finer
approximation to give a more accurate answer.</p></li>
<li><p><strong>good_degs</strong> (<em>numpy array</em>) – Interpoation degrees that are guaranteed to give an approximation valid
to within approx_tol.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zeros</strong> – The real zeros of the functions in the interval [a,b].</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.transform">
<code class="descclassname">yroots.subdivision.</code><code class="descname">transform</code><span class="sig-paren">(</span><em>x</em>, <em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms points from the interval [-1,1] to the interval [a,b].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy array</em>) – The points to be tranformed.</p></li>
<li><p><strong>a</strong> (<em>float</em><em> or </em><em>numpy array</em>) – The lower bound on the interval. Float if one-dimensional,
numpy array if multi-dimensional.</p></li>
<li><p><strong>b</strong> (<em>float</em><em> or </em><em>numpy array</em>) – The upper bound on the interval. Float if one-dimensional,
numpy array if multi-dimensional.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transform</strong> – The transformed points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Example 1 - Scaling the points to a larger interval in one dimension.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([3., 4., 5.])</span>
</pre></div>
</div>
<p>Example 2 - Multidimensional points</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">33</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[1.75 , 3.   ],</span>
<span class="go">       [1.625, 2.665],</span>
<span class="go">       [1.   , 2.3  ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="yroots.subdivision.trim_coeffs">
<code class="descclassname">yroots.subdivision.</code><code class="descname">trim_coeffs</code><span class="sig-paren">(</span><em>coeffs</em>, <em>approx_tol</em>, <em>solve_tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.subdivision.trim_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim the coefficient matrices so they are stable and choose a direction to divide in.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeffs</strong> (<em>list</em>) – The coefficient matrices of the Chebyshev polynomials we are solving.</p></li>
<li><p><strong>approx_tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
<li><p><strong>solve_tol</strong> (<em>float</em>) – The tolerance to pass into division solve.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>polys</strong> (<em>list</em>) – The reduced degree Chebyshev polynomials.</p></li>
<li><p><strong>divisor_var</strong> (<em>int # TODO Remove because of the division matrix?</em>) – What direction to do the division in to be stable. -1 means we should subdivide.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.OneDimension">
<span id="one-dimension"></span><h2>One Dimension<a class="headerlink" href="#module-yroots.OneDimension" title="Permalink to this headline">¶</a></h2>
<p>Contains all the funcitons necessary for solving one-dimensional systems.</p>
<dl class="function">
<dt id="yroots.OneDimension.divCheb">
<code class="descclassname">yroots.OneDimension.</code><code class="descname">divCheb</code><span class="sig-paren">(</span><em>coeff</em>, <em>eigvals=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.OneDimension.divCheb" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the zeros of a 1-D chebyshev polynomial using a division matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff</strong> (<em>numpy array</em>) – The coefficients of the polynomial.</p></li>
<li><p><strong>eigvals</strong> (<em>bool</em>) – If True, calculates the zeros using the eigenvalues.
If False, calculates the zeros using the left eigenvectors.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints the intermediate steps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zero</strong> – An array of the zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.OneDimension.divPower">
<code class="descclassname">yroots.OneDimension.</code><code class="descname">divPower</code><span class="sig-paren">(</span><em>coeff</em>, <em>eigvals=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.OneDimension.divPower" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the zeros of a 1-D power polynomial using a division matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff</strong> (<em>numpy array</em>) – The coefficients of the polynomial.</p></li>
<li><p><strong>eigvals</strong> (<em>bool</em>) – If True, calculates the zeros using the eigenvalues.
If False, calculates the zeros using the left eigenvectors.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints the intermediate steps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zero</strong> – An array of the zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.OneDimension.getXinv">
<code class="descclassname">yroots.OneDimension.</code><code class="descname">getXinv</code><span class="sig-paren">(</span><em>coeff</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.OneDimension.getXinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for division matrix</p>
</dd></dl>

<dl class="function">
<dt id="yroots.OneDimension.multCheb">
<code class="descclassname">yroots.OneDimension.</code><code class="descname">multCheb</code><span class="sig-paren">(</span><em>coeff</em>, <em>eigvals=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.OneDimension.multCheb" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the zeros of a 1-D chebyshev polynomial using a multiplication matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff</strong> (<em>numpy array</em>) – The coefficients of the polynomial.</p></li>
<li><p><strong>eigvals</strong> (<em>bool</em>) – If True, calculates the zeros using the eigenvalues.
If False, calculates the zeros using the left eigenvectors.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints the intermediate steps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zero</strong> – An array of the zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.OneDimension.multPower">
<code class="descclassname">yroots.OneDimension.</code><code class="descname">multPower</code><span class="sig-paren">(</span><em>coeff</em>, <em>eigvals=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.OneDimension.multPower" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the zeros of a 1-D power polynomial using a rotated multiplication matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff</strong> (<em>numpy array</em>) – The coefficients of the polynomial.</p></li>
<li><p><strong>eigvals</strong> (<em>bool</em>) – If True, calculates the zeros using the eigenvalues.
If False, calculates the zeros using the left eigenvectors.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints the intermediate steps.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zero</strong> – An array of the zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.OneDimension.solve">
<code class="descclassname">yroots.OneDimension.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>poly</em>, <em>MSmatrix=0</em>, <em>eigvals=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.OneDimension.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the zeros of a 1-D polynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly</strong> (<a class="reference internal" href="#yroots.polynomial.Polynomial" title="yroots.polynomial.Polynomial"><em>Polynomial</em></a>) – The polynomial to find the roots of.</p></li>
<li><p><strong>MSmatrix</strong> (<em>int</em>) – <p>Controls which Moller-Stetter matrix is constructed
For a univariate polynomial, the options are:</p>
<blockquote>
<div><p>0 (default) – The companion or colleague matrix
-1 – The inverse of the companion or colleague matrix</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>one_dimensional_solve</strong> – An array of the zeros.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.Multiplication">
<span id="multiplication"></span><h2>Multiplication<a class="headerlink" href="#module-yroots.Multiplication" title="Permalink to this headline">¶</a></h2>
<p>Multiplication contains the functions necessary to solve for the roots of a system
using a Macaulay matrix that represents a multiplcation by x operator. This includes
reducing the Macaulay matrix, finding a good choice of basis, and solving the system
for the roots.</p>
<dl class="function">
<dt id="yroots.Multiplication.MSMultMatrix">
<code class="descclassname">yroots.Multiplication.</code><code class="descname">MSMultMatrix</code><span class="sig-paren">(</span><em>polys</em>, <em>poly_type</em>, <em>verbose=False</em>, <em>MSmatrix=0</em>, <em>tol=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Multiplication.MSMultMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the multiplication matrix using the reduced Macaulay matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>array-like</em>) – The polynomials to find the common zeros of.</p></li>
<li><p><strong>poly_type</strong> (<em>string</em>) – The type of the polynomials in polys.</p></li>
<li><p><strong>MSmatrix</strong> (<em>int</em>) – <dl class="simple">
<dt>Controls which Moller-Stetter matrix is constructed. The options are:</dt><dd><p>0 (default) – The Moller-Stetter matrix of a random polynomial
Some positive integer i &lt; dimension – The Moller-Stetter matrix of x_i</p>
</dd>
</dl>
</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints information about how the roots are computed.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – Tolerance, how small a number has to be before it’s considered to be 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>multiplicationMatrix</strong> (<em>2D numpy array</em>) – The multiplication matrix for a random polynomial f</p></li>
<li><p><strong>var_dict</strong> (<em>dictionary</em>) – Maps each variable to its position in the vector space basis</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Multiplication.MacaulayReduction">
<code class="descclassname">yroots.Multiplication.</code><code class="descname">MacaulayReduction</code><span class="sig-paren">(</span><em>initial_poly_list</em>, <em>tol=0</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Multiplication.MacaulayReduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the Macaulay matrix to find a vector basis for the system of polynomials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_poly_list</strong> (<em>list</em>) – The polynomials in the system we are solving.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – How small we want a number to be before assuming it is zero.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints out the process of reducing the Macaulay Matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>basisDict</strong> (<em>dict</em>) – A dictionary of terms not in the vector basis to things in the vector
basis that the term can be reduced to.</p></li>
<li><p><strong>VB</strong> (<em>numpy array</em>) – The terms in the vector basis, each row being a term.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Multiplication.create_matrix">
<code class="descclassname">yroots.Multiplication.</code><code class="descname">create_matrix</code><span class="sig-paren">(</span><em>poly_coeffs</em>, <em>degree</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Multiplication.create_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a Macaulay matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly_coeffs</strong> (<em>list of numpy arrays</em>) – Contains numpy arrays that hold the coefficients of the polynomials
to be put in the matrix.</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – The degree of the Macaulay Matrix</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the polynomials going into the matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matrix</strong> (<em>2D numpy array</em>) – The Macaulay matrix.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – The ith row is the term represented by the ith column of the matrix.</p></li>
<li><p><strong>cuts</strong> (<em>tuple</em>) – When the matrix is reduced it is split into 3 parts with restricted
pivoting. These numbers indicate where those cuts happen.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Multiplication.makeBasisDict">
<code class="descclassname">yroots.Multiplication.</code><code class="descname">makeBasisDict</code><span class="sig-paren">(</span><em>matrix</em>, <em>matrix_terms</em>, <em>VB</em>, <em>power</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Multiplication.makeBasisDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the basisDict.</p>
<p>This is a dictionary of the terms on the diagonal of the reduced Macaulay
matrix to the terms in the Vector Basis. It is used to create the
multiplication matrix in root_finder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>numpy array</em>) – The reduced Macaulay matrix.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – The terms in the matrix. The i’th row is the term represented by the
i’th column of the matrix.</p></li>
<li><p><strong>VB</strong> (<em>numpy array</em>) – Each row is a term in the vector basis.</p></li>
<li><p><strong>power</strong> (<em>bool</em>) – If True, the initial polynomials were MultiPower. If False, they
were MultiCheb.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>basisDict</strong> – Maps terms on the diagonal of the reduced Macaulay matrix (tuples) to
numpy arrays that represent the terms reduction into the Vector Basis.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Multiplication.multiplication">
<code class="descclassname">yroots.Multiplication.</code><code class="descname">multiplication</code><span class="sig-paren">(</span><em>polys</em>, <em>verbose=False</em>, <em>MSmatrix=0</em>, <em>return_all_roots=True</em>, <em>tol=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Multiplication.multiplication" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the roots of the given list of multidimensional polynomials using
a multiplication matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list of polynomial objects</em>) – Polynomials to find the common roots of.</p></li>
<li><p><strong>MSmatrix</strong> (<em>int</em>) – <dl class="simple">
<dt>Controls which Moller-Stetter matrix is constructed. The options are:</dt><dd><p>0 (default):The Moller-Stetter matrix of a random polynomial
Some positive integer i &lt; dimension: The Moller-Stetter matrix of x_i</p>
</dd>
</dl>
</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints information about how the roots are computed.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – Tolerance of the function - how small a number has to be before
it’s considered to be 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>roots</strong> – The common roots of the polynomials. Each row is a root.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Multiplication.sorted_matrix_terms">
<code class="descclassname">yroots.Multiplication.</code><code class="descname">sorted_matrix_terms</code><span class="sig-paren">(</span><em>degree</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Multiplication.sorted_matrix_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the matrix_terms sorted in the term order needed for Macaulay reduction.
The highest terms come first and the x,y,z etc. monomials last.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>degree</strong> (<em>int</em>) – The degree of the Macaulay Matrix</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the polynomials going into the matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sorted_matrix_terms</strong> (<em>numpy array</em>) – The sorted matrix_terms. The ith row is the term represented by the
ith column of the matrix.</p></li>
<li><p><strong>cuts</strong> (<em>tuple</em>) – When the matrix is reduced it is split into 3 parts with restricted
pivoting. These numbers indicate where those cuts happen.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.IntervalChecks">
<span id="interval-checks"></span><h2>Interval Checks<a class="headerlink" href="#module-yroots.IntervalChecks" title="Permalink to this headline">¶</a></h2>
<p>The check functions are all functions that take in a coefficent matrix and run a quick check
to determine if there can ever be zeros on the unit box there. They are then
put into the list all_bound_check_functions in the order we want to run them
(probably fastest first). These are then all run to throw out intervals as possible.</p>
<dl class="class">
<dt id="yroots.IntervalChecks.IntervalData">
<em class="property">class </em><code class="descclassname">yroots.IntervalChecks.</code><code class="descname">IntervalData</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to handle all the things related to intervals. It holds and runs the interval checks
and also tracks what happened to each interval, and how much progress has been made.</p>
<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.interval_checks">
<code class="descname">interval_checks</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.interval_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of functions. Each function accepts a coefficient matrix and a tolerance,
and returns whether the Chebyshev Polynomial represented by that matrix, and
accurate to within that tolerance, can ever be zero on the n dimensional interval [-1,1].</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.subinterval_checks">
<code class="descname">subinterval_checks</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.subinterval_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of functions. Each function accepts a coefficient matrix, a list of intervals, a list of
sign changes,and a tolerance. It then returns a list of booleans whether the Chebyshev Polynomial
represented by that matrix, and accurate to within that tolerance, can ever be zero on the given intervals.
The list of sign changes represents if we already know the function changes sign on a given interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.a">
<code class="descname">a</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.a" title="Permalink to this definition">¶</a></dt>
<dd><p>The lower bounds of the overall interval to solve on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.b">
<code class="descname">b</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.b" title="Permalink to this definition">¶</a></dt>
<dd><p>The upper bounds of the overall interval to solve on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.interval_results">
<code class="descname">interval_results</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.interval_results" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary of funciton names to lists of intervals that were solved by that function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.total_area">
<code class="descname">total_area</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.total_area" title="Permalink to this definition">¶</a></dt>
<dd><p>The total n dimensional volume of the overall interval being solved on.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.current_area">
<code class="descname">current_area</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.current_area" title="Permalink to this definition">¶</a></dt>
<dd><p>How much of the n dimensional volume has been checked.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.polishing">
<code class="descname">polishing</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.polishing" title="Permalink to this definition">¶</a></dt>
<dd><p>If true this class is just being used as a shell to pass into the polish code.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yroots.IntervalChecks.IntervalData.tick">
<code class="descname">tick</code><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Keeps track of how many intervals have been solved. Every 100 it resets and prints the progress.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes everything.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.check_intervals">
<code class="descname">check_intervals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.check_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a polynomial can be zero on an interval.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.check_subintervals">
<code class="descname">check_subintervals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.check_subintervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a polynomial can be zero on an list of intervals.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.track_interval">
<code class="descname">track_interval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.track_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Tracks what happened to a given interval.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.print_progress">
<code class="descname">print_progress</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.print_progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints what percentage of the domain has been searched.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.print_results">
<code class="descname">print_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the results of how much each method contributed to the overall search.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.plot_results">
<code class="descname">plot_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.plot_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the results of subdivision solve.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.IntervalChecks.IntervalData.check_interval">
<code class="descname">check_interval</code><span class="sig-paren">(</span><em>coeff</em>, <em>approx_tol</em>, <em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.IntervalData.check_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the interval checks on the interval [a,b].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff</strong> (<em>numpy array.</em>) – The coefficient matrix of the Chebyshev approximation to check.</p></li>
<li><p><strong>approx_tol</strong> (<em>float</em>) – The sup norm bound on the approximation error.</p></li>
<li><p><strong>a</strong> (<em>numpy array</em>) – The lower bounds of the interval to check.</p></li>
<li><p><strong>b</strong> (<em>numpy array</em>) – The upper bounds of the interval to check.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>check_interval</strong> – True if we can throw out the interval. Otherwise False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">check_subintervals</code><span class="sig-paren">(</span><em>subintervals</em>, <em>scaled_subintervals</em>, <em>polys</em>, <em>change_sign</em>, <em>approx_tol</em><span class="sig-paren">)</span></dt>
<dd><p>Runs the subinterval checks on the given intervals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subintervals</strong> (<em>list</em>) – A list of the intervals to check.</p></li>
<li><p><strong>scaled_subintervals</strong> (<em>list</em>) – A list of the intervals to check, scaled to the unit box that the approxiations are valid on.</p></li>
<li><p><strong>polys</strong> (<em>list</em>) – The MultiCheb polynomials that approximate the functions on these intervals.</p></li>
<li><p><strong>change_sign</strong> (<em>list</em>) – A list of bools of whether we know the functions can change sign on the subintervals.</p></li>
<li><p><strong>approx_tol</strong> (<em>float</em>) – The sup norm bound on the approximation error.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>check_interval</strong> – True if we can throw out the interval. Otherwise False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">plot_results</code><span class="sig-paren">(</span><em>funcs</em>, <em>zeros</em>, <em>plot_intervals</em><span class="sig-paren">)</span></dt>
<dd><p>Prints the results of subdivision solve. Only works if the funcitons are two dimensional.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>funcs</strong> (<em>list</em>) – A list of the functions the were solved</p></li>
<li><p><strong>zeros</strong> (<em>numpy array</em>) – Each row is a zero of the funcitons</p></li>
<li><p><strong>plot_intervals</strong> (<em>bool</em>) – If true, shows on the plot which areas were solved by which check/method.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">print_progress</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Prints the progress of subdivision solve. Only prints every 100th
time this function is called to save time.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">print_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Prints the results of subdivision solve, how many intervals there
were and what percent were solved by each check/method.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">track_interval</code><span class="sig-paren">(</span><em>name</em>, <em>interval</em><span class="sig-paren">)</span></dt>
<dd><p>Stores what happened to a given interval</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>string</em>) – The name of the check or process (Division, Base Case) that solved this interval.</p></li>
<li><p><strong>interval</strong> (<em>list</em>) – [a,b] where a and b are the lower and upper bound of the interval to track.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.constant_term_check">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">constant_term_check</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.constant_term_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the constant term is bigger than all the other terms combined
using the fact that each Chebyshev monomial is bounded by 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>constant_term_check</strong> – False if the function is guarenteed to never be zero in the unit box,
True otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.cubic_check">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">cubic_check</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.cubic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Like the constant_term, but splits the coefficient matrix into
one-dimensional cubics and uses the extreme values of those to get a better bound.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cubic_check</strong> – False if the function is guarenteed to never be zero in the unit box,
True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.extreme_val3">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">extreme_val3</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>maxx=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.extreme_val3" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the extreme value of test_coeff on -1 to 1, used by quad_check.</p>
<p>test_coeff is [a,b,c] and represents the funciton a + bx + c(2x^2 - 1).
Basic calculus can be used to find the extreme values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – Array representing [a,b,c].</p></li>
<li><p><strong>maxx</strong> (<em>bool</em>) – If true returns the absolute value of the max of the funciton,
otherwise returns the absolute value of the min of the function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>extreme_val3</strong> – The extreme value (max or min) of the absolute value of a + bx + c(2x^2 - 1).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.extreme_val4">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">extreme_val4</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>maxx=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.extreme_val4" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the extreme value of test_coeff on -1 to 1, used by cubic_check</p>
<p>test_coeff is [a,b,c,d] and represents the funciton a + bx + c(2x^2 - 1) + d*(4x^3 - 3x).
Basic calculus can be used to find the extreme values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – Array representing [a,b,c,d]</p></li>
<li><p><strong>maxx</strong> (<em>bool</em>) – If true returns the absolute value of the max of the funciton, otherwise returns
the absolute value of the min of the function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>extreme_val4</strong> – The extreme value (max or min) of the absolute value of a + bx + c(2x^2 - 1) + d*(4x^3 - 3x).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.full_cubic_check">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">full_cubic_check</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.full_cubic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the cubic_check in each possible direction to get as much out of it as possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>full_cubic_check</strong> – False if the function is guarenteed to never be zero in the unit box,
True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.full_quad_check">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">full_quad_check</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.full_quad_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the quad_check in each possible direction to get as much out
of it as possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>full_quad_check</strong> – False if the function is guarenteed to never be zero in the unit box,
True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.linear_check">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">linear_check</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>intervals</em>, <em>change_sign</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.linear_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the max of the linear part of the approximation and compares
to the sum of the other terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check.</p></li>
<li><p><strong>intervals</strong> (<em>list</em>) – A list of the intervals to check.</p></li>
<li><p><strong>change_sign</strong> (<em>list</em>) – A list of bools of whether we know the functions can change sign on the subintervals.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mask</strong> – A list of the results of each interval. False if the function is
guarenteed to never be zero in the unit box, True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.quad_check">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">quad_check</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.quad_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Like the constant term check, but splits the coefficient matrix into a one dimensional
quadratics and uses the extreme values of those to get a better bound.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>quad_check</strong> – False if the function is guarenteed to never be zero in the unit box,
True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.quadratic_check">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">quadratic_check</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>intervals</em>, <em>change_sign</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.quadratic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the min of the absolute value of the quadratic part, and compares
to the sum of the rest of the terms. quadratic_check_2D and quadratic_check_3D
are faster so runs those if it can, otherwise it runs the genereic n-dimensional version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff_in</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check.</p></li>
<li><p><strong>intervals</strong> (<em>list</em>) – A list of the intervals to check.</p></li>
<li><p><strong>change_sign</strong> (<em>list</em>) – A list of bools of whether we know the functions can change sign on the subintervals.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mask</strong> – A list of the results of each interval. False if the function is
guarenteed to never be zero in the unit box, True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.quadratic_check_2D">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">quadratic_check_2D</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>intervals</em>, <em>change_sign</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.quadratic_check_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the min of the absolute value of the quadratic part, and compares to the sum of the
rest of the terms in 2 dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff_in</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check</p></li>
<li><p><strong>intervals</strong> (<em>list</em>) – A list of the intervals to check.</p></li>
<li><p><strong>change_sign</strong> (<em>list</em>) – A list of bools of whether we know the functions can change sign on the subintervals.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mask</strong> – A list of the results of each interval. False if the function is guarenteed to never be zero
in the unit box, True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.quadratic_check_3D">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">quadratic_check_3D</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>intervals</em>, <em>change_sign</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.quadratic_check_3D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Finds the min of the absolute value of the quadratic part, and compares</dt><dd><p>to the sum of the rest of the terms in 3 dimensions.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff_in</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check</p></li>
<li><p><strong>intervals</strong> (<em>list</em>) – A list of the intervals to check.</p></li>
<li><p><strong>change_sign</strong> (<em>list</em>) – A list of bools of whether we know the functions can change sign on the subintervals.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mask</strong> – A list of the results of each interval. False if the function is
guarenteed to never be zero in the unit box, True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.IntervalChecks.quadratic_check_nd">
<code class="descclassname">yroots.IntervalChecks.</code><code class="descname">quadratic_check_nd</code><span class="sig-paren">(</span><em>test_coeff</em>, <em>intervals</em>, <em>change_sign</em>, <em>tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.IntervalChecks.quadratic_check_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the min of the absolute value of the quadratic part, and compares to the sum of the
rest of the terms in n-dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_coeff_in</strong> (<em>numpy array</em>) – The coefficient matrix of the polynomial to check</p></li>
<li><p><strong>intervals</strong> (<em>list</em>) – A list of the intervals to check.</p></li>
<li><p><strong>change_sign</strong> (<em>list</em>) – A list of bools of whether we know the functions can change sign on the subintervals.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The bound of the sup norm error of the chebyshev approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mask</strong> – A list of the results of each interval. False if the function is guarenteed to never be zero
in the unit box, True otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" id="macaulayreduce" />
<div class="section" id="module-yroots.MacaulayReduce">
<span id="macaulay-reduce"></span><h2>Macaulay Reduce<a class="headerlink" href="#module-yroots.MacaulayReduce" title="Permalink to this headline">¶</a></h2>
<p>Macaulay Reduce contains functions that are helpful when reducing the Macaulay
matrix when solving a system of polynomials.</p>
<dl class="function">
<dt id="yroots.MacaulayReduce.add_polys">
<code class="descclassname">yroots.MacaulayReduce.</code><code class="descname">add_polys</code><span class="sig-paren">(</span><em>degree</em>, <em>poly</em>, <em>poly_coeff_list</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.MacaulayReduce.add_polys" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds polynomials to a Macaulay Matrix.</p>
<dl class="simple">
<dt>This function is called on one polynomial and adds all monomial multiples of</dt><dd><p>it to the matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>degree</strong> (<em>int</em>) – The degree of the Macaulay Matrix</p></li>
<li><p><strong>poly</strong> (<a class="reference internal" href="#yroots.polynomial.Polynomial" title="yroots.polynomial.Polynomial"><em>Polynomial</em></a>) – One of the polynomials used to make the matrix.</p></li>
<li><p><strong>poly_coeff_list</strong> (<em>list</em>) – A list of all the current polynomials in the matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>poly_coeff_list</strong> – The original list of polynomials in the matrix with the new monomial
multiplications of poly added.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.MacaulayReduce.find_degree">
<code class="descclassname">yroots.MacaulayReduce.</code><code class="descname">find_degree</code><span class="sig-paren">(</span><em>poly_list</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.MacaulayReduce.find_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the appropriate degree for the Macaulay Matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly_list</strong> (<em>list</em>) – The polynomials used to construct the matrix.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True prints the degree</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>find_degree</strong> – The degree of the Macaulay Matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.MacaulayReduce.rrqr_reduceMacaulay">
<code class="descclassname">yroots.MacaulayReduce.</code><code class="descname">rrqr_reduceMacaulay</code><span class="sig-paren">(</span><em>matrix</em>, <em>matrix_terms</em>, <em>cuts</em>, <em>accuracy=1e-10</em>, <em>return_perm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.MacaulayReduce.rrqr_reduceMacaulay" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces a Macaulay matrix, BYU style.</p>
<p>The matrix is split into the shape
A B C
D E F
Where A is square and contains all the highest terms, and C contains all
the x,y,z etc. terms. The lengths are determined by the matrix_shape_stuff
tuple. First A and D are reduced using rrqr without pivoting, and then the
rest of the matrix is multiplied by Q.T to change it accordingly. Then E
is reduced by rrqr with pivoting, the rows of B are shifted accordingly,
and F is multipled by Q.T to change it accordingly. This is all done in
place to save memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>numpy array.</em>) – The Macaulay matrix, sorted in BYU style.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – Each row of the array contains a term in the matrix. The i’th row
corresponds to the i’th column in the matrix.</p></li>
<li><p><strong>cuts</strong> (<em>tuple</em>) – When the matrix is reduced it is split into 3 parts with restricted
pivoting. These numbers indicate where those cuts happen.</p></li>
<li><p><strong>accuracy</strong> (<em>float</em>) – Throws an error if the condition number of the backsolve is more than 1/accuracy.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matrix</strong> (<em>numpy array</em>) – The reduced matrix.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – The resorted matrix_terms.
If something goes wrong, returns -1, -1</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.MacaulayReduce.rrqr_reduceMacaulay2">
<code class="descclassname">yroots.MacaulayReduce.</code><code class="descname">rrqr_reduceMacaulay2</code><span class="sig-paren">(</span><em>matrix</em>, <em>matrix_terms</em>, <em>cuts</em>, <em>accuracy=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.MacaulayReduce.rrqr_reduceMacaulay2" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces a Macaulay matrix, BYU style</p>
<p>This function does the same thing as rrqr_reduceMacaulay but uses
qr_multiply instead of qr and a multiplication
to make the function faster and more memory efficient.</p>
<p>This function only works properly if the bottom left (D) part of the matrix is zero</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>numpy array.</em>) – The Macaulay matrix, sorted in BYU style.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – Each row of the array contains a term in the matrix. The i’th row corresponds to
the i’th column in the matrix.</p></li>
<li><p><strong>cuts</strong> (<em>tuple</em>) – When the matrix is reduced it is split into 3 parts with restricted pivoting. These numbers indicate
where those cuts happen.</p></li>
<li><p><strong>accuracy</strong> (<em>float</em>) – What is determined to be 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matrix</strong> (<em>numpy array</em>) – The reduced matrix.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – The resorted matrix_terms.
If something goes wrong, returns -1, -1</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.polynomial">
<span id="polynomial"></span><h2>Polynomial<a class="headerlink" href="#module-yroots.polynomial" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="yroots.polynomial.MultiCheb">
<em class="property">class </em><code class="descclassname">yroots.polynomial.</code><code class="descname">MultiCheb</code><span class="sig-paren">(</span><em>coeff</em>, <em>order='degrevlex'</em>, <em>lead_term=None</em>, <em>clean_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiCheb" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to represent a Chebyshev polynomial.</p>
<dl class="attribute">
<dt id="yroots.polynomial.MultiCheb.coeff">
<code class="descname">coeff</code><a class="headerlink" href="#yroots.polynomial.MultiCheb.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The coefficient matrix represented in the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiCheb.dim">
<code class="descname">dim</code><a class="headerlink" href="#yroots.polynomial.MultiCheb.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dimensions of the coefficient matrix</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiCheb.order">
<code class="descname">order</code><a class="headerlink" href="#yroots.polynomial.MultiCheb.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordering type given as a string.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiCheb.shape">
<code class="descname">shape</code><a class="headerlink" href="#yroots.polynomial.MultiCheb.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the coefficient matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiCheb.lead_term">
<code class="descname">lead_term</code><a class="headerlink" href="#yroots.polynomial.MultiCheb.lead_term" title="Permalink to this definition">¶</a></dt>
<dd><p>The polynomial term with the largest total degree.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiCheb.degree">
<code class="descname">degree</code><a class="headerlink" href="#yroots.polynomial.MultiCheb.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>The total degree of the lead_term.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiCheb.lead_coeff">
<code class="descname">lead_coeff</code><a class="headerlink" href="#yroots.polynomial.MultiCheb.lead_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The coeff of the lead_term.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – number of variables, dimension of polynomial system.</p></li>
<li><p><strong>terms</strong> (<em>int</em>) – highest term of single variable power polynomials.</p></li>
<li><p><strong>coeff</strong> (<em>list</em><em>(</em><em>terms**dim</em><em>) or </em><em>np.array</em><em> (</em><em>[</em><em>terms</em><em>,</em><em>] </em><em>* dim</em><em>)</em>) – coefficents in given ordering.</p></li>
<li><p><strong>order</strong> (<em>string</em>) – monomial ordering desired for Grobner calculations.</p></li>
<li><p><strong>lead_term</strong> (<em>list</em>) – the index of the current leading coefficent.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="yroots.polynomial.MultiCheb.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiCheb.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two MultiCheb polynomials.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiCheb.__sub__">
<code class="descname">__sub__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiCheb.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract two MultiCheb polynomials.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiCheb.mon_mult">
<code class="descname">mon_mult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiCheb.mon_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply a MultiCheb monomial by a MultiCheb polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiCheb.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiCheb.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a MultiCheb polynomial at a point.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiCheb.evaluate_grid">
<code class="descname">evaluate_grid</code><span class="sig-paren">(</span><em>xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiCheb.evaluate_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the Chebyshev polynomial on a grid of points, very efficiently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>xyz</strong> (<em>array-like</em>) – Each column contains the values for an axis. The direct product of these columns
produces the points of the desired grid.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values</strong> – The polynomial evaluated at all of the points in the grid determined by
the axis values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>complex</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiCheb.grad">
<code class="descname">grad</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiCheb.grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the gradient of the polynomial at the given point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> (<em>array-like</em>) – the point at which to evaluate the polynomial</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Gradient of the polynomial at the given point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mon_mult</code><span class="sig-paren">(</span><em>idx</em>, <em>returnType='Poly'</em><span class="sig-paren">)</span></dt>
<dd><p>Multiplies a Chebyshev polynomial by a monomial</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> (<em>tuple of ints</em>) – The index of the monomial to multiply self by.</p></li>
<li><p><strong>returnType</strong> (<em>str</em>) – If ‘Poly’ then returns a polynomial object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>MultiCheb object if returnType is ‘Poly’.</em></p></li>
<li><p><em>ndarray if returnType is “Matrix”.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yroots.polynomial.MultiPower">
<em class="property">class </em><code class="descclassname">yroots.polynomial.</code><code class="descname">MultiPower</code><span class="sig-paren">(</span><em>coeff</em>, <em>order='degrevlex'</em>, <em>lead_term=None</em>, <em>clean_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to represent a power basis polynomial.</p>
<dl class="attribute">
<dt id="yroots.polynomial.MultiPower.coeff">
<code class="descname">coeff</code><a class="headerlink" href="#yroots.polynomial.MultiPower.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The coefficient matrix represented in the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiPower.dim">
<code class="descname">dim</code><a class="headerlink" href="#yroots.polynomial.MultiPower.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dimensions of the coefficient matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiPower.order">
<code class="descname">order</code><a class="headerlink" href="#yroots.polynomial.MultiPower.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordering type given as a string.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiPower.shape">
<code class="descname">shape</code><a class="headerlink" href="#yroots.polynomial.MultiPower.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the coefficient matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiPower.lead_term">
<code class="descname">lead_term</code><a class="headerlink" href="#yroots.polynomial.MultiPower.lead_term" title="Permalink to this definition">¶</a></dt>
<dd><p>The polynomial term with the largest total degree.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiPower.degree">
<code class="descname">degree</code><a class="headerlink" href="#yroots.polynomial.MultiPower.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>The total degree of the lead_term.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.MultiPower.lead_coeff">
<code class="descname">lead_coeff</code><a class="headerlink" href="#yroots.polynomial.MultiPower.lead_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The coeff of the lead_term.</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – number of variables, dimension of polynomial system.</p></li>
<li><p><strong>terms</strong> (<em>int</em>) – highest term of single variable power polynomials</p></li>
<li><p><strong>coeff</strong> (<em>list</em><em>(</em><em>terms**dim</em><em>) or </em><em>np.array</em><em> (</em><em>[</em><em>terms</em><em>,</em><em>] </em><em>* dim</em><em>)</em>) – coefficents in given ordering.</p></li>
<li><p><strong>order</strong> (<em>string</em>) – monomial ordering desired for Grobner calculations.</p></li>
<li><p><strong>lead_term</strong> (<em>list</em>) – the index of the current leading coefficent.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="yroots.polynomial.MultiPower.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two power polynomials.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.__sub__">
<code class="descname">__sub__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract two power polynomials.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.__mul__">
<code class="descname">__mul__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply two power polynomials.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if two power polynomials are equal.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if two power polynomials are not equal.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.mon_mult">
<code class="descname">mon_mult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.mon_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies a power monomial by a power polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a power polynomial at a point.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.evaluate_grid">
<code class="descname">evaluate_grid</code><span class="sig-paren">(</span><em>xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.evaluate_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the Power polynomial on a grid of points, very efficiently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>xyz</strong> (<em>array-like</em>) – Each column contains the values for an axis. The direct product of these columns
produces the points of the desired grid.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>values</strong> – The polynomial evaluated at all of the points in the grid determined by
the axis values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>complex</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.MultiPower.grad">
<code class="descname">grad</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.MultiPower.grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the gradient of the polynomial at the given point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> (<em>array-like</em>) – the point at which to evaluate the polynomial</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Gradient of the polynomial at the given point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mon_mult</code><span class="sig-paren">(</span><em>mon</em>, <em>returnType='Poly'</em><span class="sig-paren">)</span></dt>
<dd><p>Multiplies a polynomial by a monomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon</strong> (<em>tuple</em>) – The powers in the monomial.
Ex: x^3*y^4*z^2 would be input as (3,4,2)</p></li>
<li><p><strong>returnType</strong> (<em>str</em>) – Which type of object to return.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>MultiPower object if returnType is ‘Poly’</em></p></li>
<li><p><em>ndarray if returnType is ‘Matrix’</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yroots.polynomial.Polynomial">
<em class="property">class </em><code class="descclassname">yroots.polynomial.</code><code class="descname">Polynomial</code><span class="sig-paren">(</span><em>coeff</em>, <em>order='degrevlex'</em>, <em>lead_term=None</em>, <em>clean_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass for MultiPower and MultiCheb. Contains methods and attributes
that are applicable to both subclasses.</p>
<dl class="attribute">
<dt id="yroots.polynomial.Polynomial.coeff">
<code class="descname">coeff</code><a class="headerlink" href="#yroots.polynomial.Polynomial.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The coefficient matrix represented in the object.</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.Polynomial.dim">
<code class="descname">dim</code><a class="headerlink" href="#yroots.polynomial.Polynomial.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dimensions of the coefficient matrix</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.Polynomial.order">
<code class="descname">order</code><a class="headerlink" href="#yroots.polynomial.Polynomial.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordering type given as a string</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.Polynomial.shape">
<code class="descname">shape</code><a class="headerlink" href="#yroots.polynomial.Polynomial.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the coefficient matrix</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.Polynomial.lead_term">
<code class="descname">lead_term</code><a class="headerlink" href="#yroots.polynomial.Polynomial.lead_term" title="Permalink to this definition">¶</a></dt>
<dd><p>The polynomial term with the largest total degree</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.Polynomial.degree">
<code class="descname">degree</code><a class="headerlink" href="#yroots.polynomial.Polynomial.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>The total degree of the lead_term</p>
</dd></dl>

<dl class="attribute">
<dt id="yroots.polynomial.Polynomial.lead_coeff">
<code class="descname">lead_coeff</code><a class="headerlink" href="#yroots.polynomial.Polynomial.lead_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>The coeff of the lead_term</p>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeff</strong> (<em>ndarray</em>) – Coefficients of the polynomial</p></li>
<li><p><strong>order</strong> (<em>string</em>) – </p></li>
<li><p><strong>lead_term</strong> (<em>Tuple</em>) – Default is None. Accepts tuple or tuple-like inputs</p></li>
<li><p><strong>clean_zeros</strong> (<em>bool</em>) – Default is True. If True, all extra rows, columns, etc of all zeroes are
removed from matrix of coefficients.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="yroots.polynomial.Polynomial.clean_coeff">
<code class="descname">clean_coeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.clean_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes extra rows, columns, etc of zeroes from end of matrix of coefficients</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.match_size">
<code class="descname">match_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.match_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches the shape of two matrices.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.monomialList">
<code class="descname">monomialList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.monomialList" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a list of monomials that make up the polynomial in degrevlex order.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.monSort">
<code class="descname">monSort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.monSort" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls monomial list.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.update_lead_term">
<code class="descname">update_lead_term</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.update_lead_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the lead_term of a polynomial</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates a polynomial at a certain point.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if two polynomials are equal.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if two polynomials are not equal.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">clean_coeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Gets rid of any 0’s on the outside of the coeff matrix, not giving any info.</p>
</dd></dl>

<dl class="method">
<dt id="yroots.polynomial.Polynomial.grad">
<code class="descname">grad</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.Polynomial.grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the gradient of the polynomial at the given point. This method is overridden
by the MultiPower and MultiCheb classes, so this definition only
checks if the polynomial can be evaluated at the given point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> (<em>array-like</em>) – the point at which to evaluate the polynomial</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grad</strong> – Gradient of the polynomial at the given point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.cheb2poly">
<code class="descclassname">yroots.polynomial.</code><code class="descname">cheb2poly</code><span class="sig-paren">(</span><em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.cheb2poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Chebyshev polynomial to a standard polynomial in multiple dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>T</strong> (<a class="reference internal" href="#yroots.polynomial.MultiCheb" title="yroots.polynomial.MultiCheb"><em>MultiCheb</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#yroots.polynomial.MultiPower" title="yroots.polynomial.MultiPower">MultiPower</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.chebvalnd">
<code class="descclassname">yroots.polynomial.</code><code class="descname">chebvalnd</code><span class="sig-paren">(</span><em>x</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.chebvalnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a MultiCheb object at a point x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – Point to evaluate at</p></li>
<li><p><strong>c</strong> (<em>ndarray</em>) – Tensor of Chebyshev coefficients</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>c</strong> – Value of the MultiCheb polynomial at x</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.conv_cheb">
<code class="descclassname">yroots.polynomial.</code><code class="descname">conv_cheb</code><span class="sig-paren">(</span><em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.conv_cheb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Chebyshev polynomial to the power basis representation in one dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>T</strong> (<em>array_like</em>) – A one dimensional array_like object that represents the coeff of a
Chebyshev polynomial.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A one dimensional array that represents the coeff of a power basis polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.conv_poly">
<code class="descclassname">yroots.polynomial.</code><code class="descname">conv_poly</code><span class="sig-paren">(</span><em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.conv_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a standard polynomial to a Chebyshev polynomial in one dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> (<em>array_like</em>) – A one dimensional array_like object that represents the coeff of a
power basis polynomial.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A one dimensional array that represents the coeff of a Chebyshev polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.getPoly">
<code class="descclassname">yroots.polynomial.</code><code class="descname">getPoly</code><span class="sig-paren">(</span><em>deg</em>, <em>dim</em>, <em>power</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.getPoly" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper function for testing. Returns a random upper triangular polynomial of the given dimension and degree.
power is a boolean indicating whether or not the polynomial should be MultiPower.</p>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.is_power">
<code class="descclassname">yroots.polynomial.</code><code class="descname">is_power</code><span class="sig-paren">(</span><em>poly_list</em>, <em>return_string=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.is_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the type of a list of polynomials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>poly_list</strong> (<em>list of polynomial objects</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_power</strong> – If the list is all power objects then returns True, if all obects are
chebyshev then returns False, and if there is a mix then an error is
raised</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.poly2cheb">
<code class="descclassname">yroots.polynomial.</code><code class="descname">poly2cheb</code><span class="sig-paren">(</span><em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.poly2cheb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a standard polynomial to a Chebyshev polynomial in multiple dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> (<a class="reference internal" href="#yroots.polynomial.MultiPower" title="yroots.polynomial.MultiPower"><em>MultiPower</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The multi-dimensional Chebyshev polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#yroots.polynomial.MultiCheb" title="yroots.polynomial.MultiCheb">MultiCheb</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.polyvalnd">
<code class="descclassname">yroots.polynomial.</code><code class="descname">polyvalnd</code><span class="sig-paren">(</span><em>x</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.polyvalnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a MultiPower object at a point x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – Point to evaluate at</p></li>
<li><p><strong>c</strong> (<em>ndarray</em>) – Tensor of Polynomial coefficients</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>c</strong> – Value of the MultiPower polynomial at x</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.polynomial.solve">
<code class="descclassname">yroots.polynomial.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>poly1</em>, <em>poly2</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polynomial.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies two polynomials given only their coefficients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>tuple</strong><strong>)</strong> (<em>poly1</em><em>,</em><em>poly2</em>) – tuples of coefficients of polynomials, in descending order of degree</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a tuple of coefficents for the resultant polynomial</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.polyroots">
<span id="polyroots"></span><h2>Polyroots<a class="headerlink" href="#module-yroots.polyroots" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="yroots.polyroots.solve">
<code class="descclassname">yroots.polyroots.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>polys</em>, <em>MSmatrix=0</em>, <em>eigvals=True</em>, <em>verbose=False</em>, <em>return_all_roots=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.polyroots.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the roots of the given list of polynomials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list of polynomial objects</em>) – Polynomials to find the common roots of.</p></li>
<li><p><strong>MSmatrix</strong> (<em>int</em>) – <p>Controls which Moller-Stetter matrix is constructed
For a univariate polynomial, the options are:</p>
<blockquote>
<div><p>0 (default) – The companion or colleague matrix, rotated 180 degrees
1 – The unrotated companion or colleague matrix
-1 – The inverse of the companion or colleague matrix</p>
</div></blockquote>
<dl class="simple">
<dt>For a multivariate polynomial, the options are:</dt><dd><p>0 (default) – The Moller-Stetter matrix of a random polynomial
Some positive integer i &lt;= dimension – The Moller-Stetter matrix of x_i, where variables are index from x1, …, xn
Some negative integer i &gt;= -dimension – The Moller-Stetter matrix of x_i-inverse</p>
</dd>
</dl>
</p></li>
<li><p><strong>eigvals</strong> (<em>bool</em>) – Whether to compute roots of univariate polynomials from eigenvalues (True) or eigenvectors (False).
Roots of multivariate polynomials are always comptued from eigenvectors</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Prints information about how the roots are computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>roots</strong> – The common roots of the polynomials. Each row is a root.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.LinearProjection">
<span id="linear-projection"></span><h2>Linear Projection<a class="headerlink" href="#module-yroots.LinearProjection" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="yroots.LinearProjection.bounding_parallelepiped">
<code class="descclassname">yroots.LinearProjection.</code><code class="descname">bounding_parallelepiped</code><span class="sig-paren">(</span><em>linear</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.LinearProjection.bounding_parallelepiped" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper function for projecting polynomials. It accepts a linear
polynomial and return vectors describing an (n-1)-dimensional parallelepiped
that covers the intersection between the linear polynomial (it’s variety)
and the n-dimensional hypercube.</p>
<p>Note: The parallelepiped can be described using just one vertex, and (n-1)
vectors, each of dimension n.</p>
<p>Second Note: This first attempt is very simple, and can be greatly improved
by creating a parallelepiped that much more closely surrounds the points.
Currently, it just makes an nd-rectangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>linear</strong> (<em>numpy array</em>) – The coefficients of the linear function.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>p0</strong> (<em>numpy array</em>) – One vertex of the parallelepiped.</p></li>
<li><p><strong>edges</strong> (<em>numpy array</em>) – Array of vectors describing the edges of the parallelepiped, from p0.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.LinearProjection.proj_approximate_nd">
<code class="descclassname">yroots.LinearProjection.</code><code class="descname">proj_approximate_nd</code><span class="sig-paren">(</span><em>f</em>, <em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.LinearProjection.proj_approximate_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the chebyshev approximation of an n-dimensional function on the
affine transformation of hypercube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>function from R^n -&gt; R</em>) – The function to project by interpolating.</p></li>
<li><p><strong>transform</strong> (<em>function from R^</em><em>(</em><em>n-1</em><em>) </em><em>-&gt; R^n</em>) – The affine function mapping the hypercube to the desired space.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>coeffs</strong> – The coefficient of the chebyshev interpolating polynomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.LinearProjection.project_down">
<code class="descclassname">yroots.LinearProjection.</code><code class="descname">project_down</code><span class="sig-paren">(</span><em>polys</em>, <em>linear</em>, <em>approx_tol</em>, <em>solve_tol</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.LinearProjection.project_down" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reduces the dimension of a polynomial system when one of
functions is linear. For polynomials in n variables, it uses an affine
transformation that maps the (n-1) dimensional hyper-square to cover the
intersection between the variety of the linear polynomial and the
n dimensional hyper-square. Then it performs chebyshev interpolation of the
functions onto this intersection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list of polynomials</em>) – The polynomials to be projected in a lower dimension by
interpolated.</p></li>
<li><p><strong>linear</strong> (<em>numpy array</em>) – The coefficents of the linear function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>proj_polys</strong> (<em>list</em>) – The projected polynomials.</p></li>
<li><p><strong>T</strong> (<em>function from R^(n-1) -&gt; R^n</em>) – This function maps the roots of the projected system to the roots of
the original system.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.LinearProjection.remove_linear">
<code class="descclassname">yroots.LinearProjection.</code><code class="descname">remove_linear</code><span class="sig-paren">(</span><em>polys</em>, <em>approx_tol</em>, <em>solve_tol</em>, <em>transform_in=None</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.LinearProjection.remove_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>This function recursively removes linear polynomials from a list by
applying the project_down function once for each linear polynomial.
This function assumes these polynomials had the zeros removed already, so that
it can rely on dimensions to detect linear polynomials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list of polynomial objects</em>) – Polynomials to find the common roots of.</p></li>
<li><p><strong>approx_tol</strong> (<em>float</em>) – A tolerance to pass into the trim_coeff.</p></li>
<li><p><strong>solve_tol</strong> (<em>float</em>) – A tolerance to pass into the trim_coeff.</p></li>
<li><p><strong>transform_in</strong> (<em>function</em>) – only intended for use in recursion</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>polys</strong> (<em>list of polynomial objects</em>) – Polynomials to find the common roots of.</p></li>
<li><p><strong>transform</strong> (<em>function</em>) – A function mapping the roots of the output system to the roots of the
original system.</p></li>
<li><p><strong>projected</strong> (<em>bool</em>) – True is projection was performed, False if no projection</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.ProjectiveSpace">
<span id="projective-space"></span><h2>Projective Space<a class="headerlink" href="#module-yroots.ProjectiveSpace" title="Permalink to this headline">¶</a></h2>
<p>Code for determining if a system of polynomials has a root at infinity
August 17, 2018</p>
<dl class="function">
<dt id="yroots.ProjectiveSpace.common_root_at_inf">
<code class="descclassname">yroots.ProjectiveSpace.</code><code class="descname">common_root_at_inf</code><span class="sig-paren">(</span><em>polys</em>, <em>return_root=False</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.ProjectiveSpace.common_root_at_inf" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if a system of upper-triagular bivariate power-basis polynomials has a common root at infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>list</strong><strong>, </strong><strong>2</strong><strong>)</strong> (<em>polys</em>) – </p></li>
<li><p><strong>(</strong><strong>bool</strong><strong>)</strong> (<em>return_root</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>bool</strong> (<em>whether or not there is at least one root at infinity</em>)</p></li>
<li><p><strong>root</strong> (<em>(tuple) the first root at infinity it found, if any exist</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.ProjectiveSpace.pad_with_zeros">
<code class="descclassname">yroots.ProjectiveSpace.</code><code class="descname">pad_with_zeros</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.ProjectiveSpace.pad_with_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends a nonsquare matrix into a square matrix with zeros in it.
e.g. if A is a tall matrix, returns [A|0]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>(</strong><strong>np.array</strong><strong>)</strong> (<em>matrix</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>square matrix</strong> – square matrix with zeros in it (np.array)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.ProjectiveSpace.roots_at_inf">
<code class="descclassname">yroots.ProjectiveSpace.</code><code class="descname">roots_at_inf</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.ProjectiveSpace.roots_at_inf" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the roots at infinity of a homogenous, bivarite power-basis
polynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>poly</strong> (<em>a bivariate power-basis polynomial</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>inf_roots_f_d</strong> – The roots at infinity of the polynomial (list of tuples). In the form
(x,y). Since at infinity, z = 0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of tuples</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.Division">
<span id="division"></span><h2>Division<a class="headerlink" href="#module-yroots.Division" title="Permalink to this headline">¶</a></h2>
<p>Division contains the functions necessary to solve for the roots of a system
using a Macaulay matrix that represents a division by x_i operator. This
includes reducing the Macaulay matrix, finding a good choice of basis, and
solving the system for the roots. This method is similar to multiplication,
but is an experimental method for solving a specific class of problems quickly
and efficiently. Currently, it’s very comprable to Mutliplication, so more
research needs to be done.</p>
<dl class="function">
<dt id="yroots.Division.build_division_matrix">
<code class="descclassname">yroots.Division.</code><code class="descname">build_division_matrix</code><span class="sig-paren">(</span><em>VB</em>, <em>VB_spot_dict</em>, <em>diag_reduction_dict</em>, <em>inv_reduction_dict</em>, <em>divisor_terms_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.build_division_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the division matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>VB</strong> (<em>numpy array</em>) – The vector basis.</p></li>
<li><p><strong>VB_spot_dict</strong> (<em>dictionary</em>) – A dictionary of term in the vector basis to their spot in the vector basis.</p></li>
<li><p><strong>diag_reduction_dict</strong> (<em>dictionary</em>) – A dictionary of terms on the diagonal to their reduction in the vector basis.</p></li>
<li><p><strong>inv_reduction_dict</strong> (<em>dictionary</em>) – A dictionary of terms of type y^k/x to their reduction in the vector basis.</p></li>
<li><p><strong>divisor_terms_dict</strong> (<em>dictionary</em>) – A dictionary of terms to the terms in their dividend when divided by x.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>div_matrix</strong> – The division matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.condeig">
<code class="descclassname">yroots.Division.</code><code class="descname">condeig</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.condeig" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the condition numbers of the eigenvalues of A</p>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.condeigv">
<code class="descclassname">yroots.Division.</code><code class="descname">condeigv</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.condeigv" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the condition numbers of the eigenvectors of A</p>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.create_matrix">
<code class="descclassname">yroots.Division.</code><code class="descname">create_matrix</code><span class="sig-paren">(</span><em>poly_coeffs</em>, <em>degree</em>, <em>dim</em>, <em>divisor_var</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.create_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a Macaulay matrix for reduction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly_coeffs</strong> (<em>list.</em>) – <dl class="simple">
<dt>Contains numpy arrays that hold the coefficients of the polynomials</dt><dd><p>to be put in the matrix.</p>
</dd>
</dl>
</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – The degree of the Macaulay Matrix</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the polynomials going into the matrix.</p></li>
<li><p><strong>divisor_var</strong> (<em>int</em>) – What variable is being divided by. 0 is x, 1 is y, etc. Defaults to x.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matrix</strong> (<em>2D numpy array</em>) – The Macaulay matrix.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – The ith row is the term represented by the ith column of the matrix.</p></li>
<li><p><strong>cuts</strong> (<em>tuple</em>) – When the matrix is reduced it is split into 3 parts with restricted
pivoting. These numbers indicate where those cuts happen.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.divide_row">
<code class="descclassname">yroots.Division.</code><code class="descname">divide_row</code><span class="sig-paren">(</span><em>coeffs</em>, <em>terms</em>, <em>term_divide_dict</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.divide_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Divides a row of the matrix by the divisor variable..</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeffs</strong> (<em>numpy array.</em>) – The numerical values of the terms we want to divide by x.</p></li>
<li><p><strong>terms</strong> (<em>numpy array</em>) – The terms corresponding to the numerical values.</p></li>
<li><p><strong>term_divide_dict</strong> (<em>dictionary</em>) – Maps each term as a tuple to a numpy array representing that term
divided by x.</p></li>
<li><p><strong>length</strong> (<em>int</em>) – The length of the rows in the inv_matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>new_row</strong> – The row we get in the inverse_matrix by dividing the first row by x.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.divide_term">
<code class="descclassname">yroots.Division.</code><code class="descname">divide_term</code><span class="sig-paren">(</span><em>term</em>, <em>inv_matrix_terms</em>, <em>inv_spot_dict</em>, <em>diag_reduction_dict</em>, <em>VB_size</em>, <em>divisor_terms_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.divide_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Divides a term of the matrix by the divisor variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> (<em>numpy array</em>) – The term to divide.</p></li>
<li><p><strong>inv_matrix_terms</strong> (<em>numpy array</em>) – The terms in the inverse matrix.</p></li>
<li><p><strong>inv_spot_dict</strong> (<em>dictionary</em>) – A dictionary of term in inv_matrix_terms to their spot in inv_matrix_terms.</p></li>
<li><p><strong>diag_reduction_dict</strong> (<em>dictionary</em>) – A dictionary of terms on the diagonal to their reduction in the vector basis.</p></li>
<li><p><strong>VB_size</strong> (<em>int</em>) – The number of elements in the vector basis.</p></li>
<li><p><strong>divisor_terms_dict</strong> (<em>dictionary</em>) – A dictionary of terms to the terms in their dividend when divided by x.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>row</strong> – The row we get in the inverse_matrix by dividing the term by x.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.division">
<code class="descclassname">yroots.Division.</code><code class="descname">division</code><span class="sig-paren">(</span><em>polys</em>, <em>divisor_var=0</em>, <em>tol=1e-10</em>, <em>verbose=False</em>, <em>polish=False</em>, <em>return_all_roots=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.division" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the common zeros of polynomials using a division matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list of MultiCheb Polynomials</em>) – The polynomials for which the common roots are found.</p></li>
<li><p><strong>divisor_var</strong> (<em>int</em>) – What variable is being divided by. 0 is x, 1 is y, etc. Defaults to x.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – The tolerance parameter for the Macaulay Reduce.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, prints information about the solve.</p></li>
<li><p><strong>polish</strong> (<em>bool</em>) – If True, runs a newton polish on the zeros before returning.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zeros</strong> – The common roots of the polynomials. Each row is a root.
Returns -1 if something goes wrong (see instances for details)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.get_divisor_terms">
<code class="descclassname">yroots.Division.</code><code class="descname">get_divisor_terms</code><span class="sig-paren">(</span><em>term</em>, <em>divisor_var</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.get_divisor_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the terms that will be present when dividing a given term by x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> (<em>numpy array</em>) – The term to divide.</p></li>
<li><p><strong>divisor_var</strong> (<em>int</em>) – What variable is being divided by. 0 is x, 1 is y, etc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>terms</strong> – Each row is a term that will be in the quotient.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.get_matrix_terms">
<code class="descclassname">yroots.Division.</code><code class="descname">get_matrix_terms</code><span class="sig-paren">(</span><em>poly_coeffs</em>, <em>dim</em>, <em>divisor_var</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.get_matrix_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the terms in the Macaulay matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly_coeffs</strong> (<em>list</em>) – A list of numpy arrays that contain the coefficients of the polynomials
to go into the Macaualy Matrix.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the polynomials in the matrix.</p></li>
<li><p><strong>divisor_var</strong> (<em>int</em>) – What variable is being divided by. 0 is x, 1 is y, etc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – The matrix_terms. The ith row is the term represented by the ith column
of the matrix.</p></li>
<li><p><strong>cuts</strong> (<em>tuple</em>) – When the matrix is reduced it is split into 3 parts with restricted
pivoting. These numbers indicate where those cuts happen.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.Division.makeBasisDict">
<code class="descclassname">yroots.Division.</code><code class="descname">makeBasisDict</code><span class="sig-paren">(</span><em>matrix</em>, <em>matrix_terms</em>, <em>VB</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.Division.makeBasisDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the basisDict.</p>
<p>This is a dictionary of the terms on the diagonal of the reduced Macaulay
matrix to the terms in the Vector Basis.
It is used to create the multiplication matrix in root_finder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>numpy array</em>) – The reduced Macaulay matrix.</p></li>
<li><p><strong>matrix_terms</strong> (<em>numpy array</em>) – The terms in the matrix. The i’th row is the term represented by the
i’th column of the matrix.</p></li>
<li><p><strong>VB</strong> (<em>numpy array</em>) – Each row is a term in the vector basis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>basisDict</strong> – Maps terms on the diagonal of the reduced Macaulay matrix (tuples) to
numpy arrays of the shape remainder_shape that represent the terms
reduction into the Vector Basis.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="module-yroots.utils">
<span id="utils"></span><h2>Utils<a class="headerlink" href="#module-yroots.utils" title="Permalink to this headline">¶</a></h2>
<p>A collection of functions used in the F4 Macaulay and TVB solvers</p>
<dl class="exception">
<dt id="yroots.utils.InstabilityWarning">
<em class="property">exception </em><code class="descclassname">yroots.utils.</code><code class="descname">InstabilityWarning</code><a class="headerlink" href="#yroots.utils.InstabilityWarning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="exception">
<dt id="yroots.utils.MacaulayError">
<em class="property">exception </em><code class="descclassname">yroots.utils.</code><code class="descname">MacaulayError</code><a class="headerlink" href="#yroots.utils.MacaulayError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="yroots.utils.Term">
<em class="property">class </em><code class="descclassname">yroots.utils.</code><code class="descname">Term</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.Term" title="Permalink to this definition">¶</a></dt>
<dd><p>Terms are just tuples of exponents with the grevlex ordering</p>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.all_permutations">
<code class="descclassname">yroots.utils.</code><code class="descname">all_permutations</code><span class="sig-paren">(</span><em>deg</em>, <em>dim</em>, <em>matrixDegree</em>, <em>permutations=None</em>, <em>current_degree=2</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.all_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the permutation arrays needed to create a Macaulay Matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int</em>) – Permutation arrays will be computed for all monomials up to this degree.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension the monomials for which permutation degrees.</p></li>
<li><p><strong>matrixDegree</strong> (<em>int</em>) – The degree of the Macaulay Matrix that will be created. This is needed to get the length of the rows.</p></li>
<li><p><strong>permutations</strong> (<em>dict</em>) – Defaults to none. The permutations that have already been computed.</p></li>
<li><p><strong>current_degree</strong> (<em>int</em>) – Defaults to 2. The degree of permutations that have already been computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutations</strong> – The keys of the dictionary are tuple representation of the monomials, and each value is
the permutation array corresponding to multiplying by that monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.all_permutations_cheb">
<code class="descclassname">yroots.utils.</code><code class="descname">all_permutations_cheb</code><span class="sig-paren">(</span><em>deg</em>, <em>dim</em>, <em>matrixDegree</em>, <em>current_degree=2</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.all_permutations_cheb" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the permutation arrays needed to create a Macaulay Matrix for Chebyshev Basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int</em>) – Permutation arrays will be computed for all monomials up to this degree.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension the monomials for which permutation degrees.</p></li>
<li><p><strong>matrixDegree</strong> (<em>int</em>) – The degree of the Macaulay Matrix that will be created. This is needed to get the length of the rows.</p></li>
<li><p><strong>current_degree</strong> (<em>int</em>) – Defaults to 2. The degree of permutations that have already been computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutations</strong> – The keys of the dictionary are tuple representation of the monomials, and each value is
the permutation array corresponding to multiplying by that monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.arrays">
<code class="descclassname">yroots.utils.</code><code class="descname">arrays</code><span class="sig-paren">(</span><em>deg</em>, <em>dim</em>, <em>mon</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a part of the permutation array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int.</em>) – The degree of the Macaulay matrix that the row is in.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the polynomials in the Macaualy matrix that the row is in.</p></li>
<li><p><strong>mon</strong> (<em>int</em>) – The monomial we are multiplying by.
0 -&gt; multiplying by x0
1 -&gt; multiplying by x1
…
n -&gt; multiplying by xn</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>arrays</strong> – The array is full of True/False values, using np.where the array is True will generate the permutation array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.cheb_perturbation2">
<code class="descclassname">yroots.utils.</code><code class="descname">cheb_perturbation2</code><span class="sig-paren">(</span><em>mult_mon</em>, <em>mons</em>, <em>mon_dict</em>, <em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.cheb_perturbation2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Cheb perturbation for the case where mon is greater than poly_mon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mult_mon</strong> (<em>tuple</em>) – the monomial that multiplies the polynomial</p></li>
<li><p><strong>mons</strong> (<em>array</em>) – Array of monomials in the polynomial</p></li>
<li><p><strong>mon_dict</strong> (<em>dict</em>) – Dictionary of the index of each monomial.</p></li>
<li><p><strong>var</strong> (<em>int</em>) – index of the variable that is being calculated</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cheb_pertubation3</strong> – list of indexes for the 3rd case of cheb mon mult</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.cheb_perturbation3">
<code class="descclassname">yroots.utils.</code><code class="descname">cheb_perturbation3</code><span class="sig-paren">(</span><em>mult_mon</em>, <em>mons</em>, <em>mon_dict</em>, <em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.cheb_perturbation3" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Cheb perturbation for the case where mon is greater than poly_mon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mult_mon</strong> (<em>tuple</em>) – the monomial that multiplies the polynomial</p></li>
<li><p><strong>mons</strong> (<em>array</em>) – Array of monomials in the polynomial</p></li>
<li><p><strong>mon_dict</strong> (<em>dict</em>) – Dictionary of the index of each monomial.</p></li>
<li><p><strong>var</strong> (<em>int</em>) – index of the variable that is being calculated</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cheb_pertubation3</strong> – list of indexes for the 3rd case of cheb mon mult</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.clean_zeros_from_matrix">
<code class="descclassname">yroots.utils.</code><code class="descname">clean_zeros_from_matrix</code><span class="sig-paren">(</span><em>array</em>, <em>accuracy=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.clean_zeros_from_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets all values in the array less than the given accuracy to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>numpy array</em>) – </p></li>
<li><p><strong>accuracy</strong> (<em>float</em><em>, </em><em>optional</em>) – Values in the matrix less than this will be set to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array</strong> – Same array, but with values less than the given accuracy set to 0.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.deg_d_polys">
<code class="descclassname">yroots.utils.</code><code class="descname">deg_d_polys</code><span class="sig-paren">(</span><em>polys</em>, <em>deg</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.deg_d_polys" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the rows of the Macaulay Matrix of degree deg.</p>
<p>Iterating through this for each needed degree creates a full rank matrix in all dimensions,
getting rid of the extra rows that are there when we do all the monomial multiplications.</p>
<p>The idea behind this algorithm comes from that cool triangle thing I drew on a board once, I have
no proof of it, but it seems to work real good.</p>
<p>It is also less stable than the other version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list.</em>) – A list of polynomials.</p></li>
<li><p><strong>deg</strong> (<em>int</em>) – The desired degree.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the polynomials.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>poly_coeff_list</strong> – A list of the polynomials of degree deg to be added to the Macaulay Matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.divides">
<code class="descclassname">yroots.utils.</code><code class="descname">divides</code><span class="sig-paren">(</span><em>mon1</em>, <em>mon2</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.divides" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon1</strong> (<em>tuple</em>) – contains the exponents of the monomial divisor</p></li>
<li><p><strong>mon2</strong> (<em>tuple</em>) – contains the exponents of the monomial dividend</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>true if mon1 divides mon2, false otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.first_x">
<code class="descclassname">yroots.utils.</code><code class="descname">first_x</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.first_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the first position of an ‘x’ in a string. If there is not x it
returns the length of the string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> (<em>str</em>) – The string of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>i</strong> – The position in the string of the first ‘x’ character. If ‘x’ does not appear in the string
the return value is the length of the string.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.get_var_list">
<code class="descclassname">yroots.utils.</code><code class="descname">get_var_list</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.get_var_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the variables [x_1, x_2, …, x_n] as tuples.</p>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.inverse_P">
<code class="descclassname">yroots.utils.</code><code class="descname">inverse_P</code><span class="sig-paren">(</span><em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.inverse_P" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverse of P, the array with column switching indexes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> (<em>array-like</em>) – 1D array P returned by scipy’s QRP decomposition.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The indexes needed to switch the columns back to their original
positions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D numpy array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.linalg.qr()</span></code></dt><dd><p>QR decomposition (with pivoting=True).</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.is_number">
<code class="descclassname">yroots.utils.</code><code class="descname">is_number</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.is_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks is a string can be converted to a number.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>string</strong> (<em>str</em>) – The string of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – Whether or not the string is a valid number.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.lcm">
<code class="descclassname">yroots.utils.</code><code class="descname">lcm</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.lcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the LCM of the two leading terms of polynomials a and b</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<em>a</em><em>,</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The lcm of the leading terms of a and b. The usual representation is
used, i.e., <span class="math notranslate nohighlight">\(x^2y^3\)</span> is represented as <span class="math notranslate nohighlight">\(\mathtt{(2,3)}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.makePolyCoeffMatrix">
<code class="descclassname">yroots.utils.</code><code class="descname">makePolyCoeffMatrix</code><span class="sig-paren">(</span><em>inputString</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.makePolyCoeffMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a string input of a polynomaial and returns the coefficient matrix for it. Usefull for making things of high
degree of dimension so you don’t have to make it by hand.</p>
<p>All strings must be of the following syntax. Ex. ‘3x0^2+2.1x1^2*x2+-14.73x0*x2^3’</p>
<ol class="arabic simple">
<li><p>There can be no spaces.</p></li>
<li><p>All monomials must be seperated by a ‘+’. If the coefficient of the monomial is negative then the ‘-‘ sign
should come after the ‘+’. This is not needed for the first monomial.</p></li>
<li><p>All variables inside a monomial are seperated by a ‘*’.</p></li>
<li><p>The power of a variable in a monomial is given folowing a ‘^’ sign.</p></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.match_poly_dimensions">
<code class="descclassname">yroots.utils.</code><code class="descname">match_poly_dimensions</code><span class="sig-paren">(</span><em>polys</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.match_poly_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches the dimensions of a list of polynomials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polys</strong> (<em>list</em>) – Polynomials of possibly different dimensions.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>new_polys</strong> – The same polynomials but of the same dimensions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.match_size">
<code class="descclassname">yroots.utils.</code><code class="descname">match_size</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.match_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches the shape of two matrixes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<em>a</em><em>,</em>) – Matrixes whose size is to be matched.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>a, b</strong> – Matrixes of equal size.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.memoize_permutaions">
<code class="descclassname">yroots.utils.</code><code class="descname">memoize_permutaions</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.memoize_permutaions" title="Permalink to this definition">¶</a></dt>
<dd><p>Specially designed for memoizing all_permutations.</p>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.mon_combos">
<code class="descclassname">yroots.utils.</code><code class="descname">mon_combos</code><span class="sig-paren">(</span><em>mon</em>, <em>numLeft</em>, <em>spot=0</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.mon_combos" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the monomials up to a given degree and returns them. Works recursively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon</strong> (<em>list</em>) – A list of zeros, the length of which is the dimension of the desired monomials. Will change
as the function searches recursively.</p></li>
<li><p><strong>numLeft</strong> (<em>int</em>) – The degree of the monomials desired. Will decrease as the function searches recursively.</p></li>
<li><p><strong>spot</strong> (<em>int</em>) – The current position in the list the function is iterating through. Defaults to 0, but increases
in each step of the recursion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>answers</strong> – A list of all the monomials.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.mon_combosHighest">
<code class="descclassname">yroots.utils.</code><code class="descname">mon_combosHighest</code><span class="sig-paren">(</span><em>mon</em>, <em>numLeft</em>, <em>spot=0</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.mon_combosHighest" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the monomials of a given degree and returns them. Works recursively.</p>
<p>Very similar to mon_combos, but only returns the monomials of the desired degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon</strong> (<em>list</em>) – A list of zeros, the length of which is the dimension of the desired monomials. Will change
as the function searches recursively.</p></li>
<li><p><strong>numLeft</strong> (<em>int</em>) – The degree of the monomials desired. Will decrease as the function searches recursively.</p></li>
<li><p><strong>spot</strong> (<em>int</em>) – The current position in the list the function is iterating through. Defaults to 0, but increases
in each step of the recursion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>answers</strong> – A list of all the monomials.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.mons_1D">
<code class="descclassname">yroots.utils.</code><code class="descname">mons_1D</code><span class="sig-paren">(</span><em>dim</em>, <em>deg</em>, <em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.mons_1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the monomials of one variable up to a given degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the monomial</p></li>
<li><p><strong>deg</strong> (<em>int</em>) – Desired degree of highest monomial returned</p></li>
<li><p><strong>var</strong> (<em>int</em>) – index of the variable of desired monomials</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mons_1D</strong> – Array of monomials where each row is a monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.newton_polish">
<code class="descclassname">yroots.utils.</code><code class="descname">newton_polish</code><span class="sig-paren">(</span><em>polys</em>, <em>root</em>, <em>niter=100</em>, <em>tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.newton_polish" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Newton’s method on a system of N polynomials in M variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list</em>) – A list of polynomial objects of the same type (MultiPower or MultiCheb).</p></li>
<li><p><strong>root</strong> (<em>ndarray</em>) – An initial guess for Newton’s method, intended to be a candidate root from root_finder.</p></li>
<li><p><strong>niter</strong> (<em>int</em>) – A maximum number of iterations of Newton’s method.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – Tolerance for convergence of Newton’s method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x1</strong> – The terminal point of Newton’s method, an estimation for a root of the system</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.num_mons">
<code class="descclassname">yroots.utils.</code><code class="descname">num_mons</code><span class="sig-paren">(</span><em>deg</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.num_mons" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of monomials of a certain degree and dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int.</em>) – The degree desired.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension desired.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>num_mons</strong> – The number of monomials of the given degree and dimension.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.num_mons_full">
<code class="descclassname">yroots.utils.</code><code class="descname">num_mons_full</code><span class="sig-paren">(</span><em>deg</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.num_mons_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of monomials of a certain dimension and less than or equal to a certian degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int.</em>) – The degree desired.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension desired.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>num_mons</strong> – The number of monomials of the given degree and dimension.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.permutation_array">
<code class="descclassname">yroots.utils.</code><code class="descname">permutation_array</code><span class="sig-paren">(</span><em>deg</em>, <em>dim</em>, <em>mon</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.permutation_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the permutation array to multiply a row of a matrix by a certain monomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int.</em>) – The degree of the Macaulay matrix that the row is in.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the polynomials in the Macaualy matrix that the row is in.</p></li>
<li><p><strong>mon</strong> (<em>int</em>) – The monomial we are multiplying by.
0 -&gt; multiplying by x0
1 -&gt; multiplying by x1
…
n -&gt; multiplying by xn</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutation_array</strong> – Permutting a row in the Macaulay matrix by this array will be equivalent to multiplying by mon.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.quotient">
<code class="descclassname">yroots.utils.</code><code class="descname">quotient</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the quotient of monomials a and b, that is, a / b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<em>a</em><em>,</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The quotient a / b</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.row_linear_dependencies">
<code class="descclassname">yroots.utils.</code><code class="descname">row_linear_dependencies</code><span class="sig-paren">(</span><em>matrix</em>, <em>accuracy=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.row_linear_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses rank revealing QR to determine which rows of the given matrix are
linearly independent and which ones are linearly dependent. (This
function needs a name change).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>(</em><em>2D numpy array</em><em>)</em>) – The matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>independentRows</strong> (<em>(list)</em>) – The indexes of the rows that are linearly independent</p></li>
<li><p><strong>dependentRows</strong> (<em>(list)</em>) – The indexes of the rows that can be removed without affecting the rank
(which are the linearly dependent rows).</p></li>
<li><p><strong>Q</strong> (<em>(2D numpy array)</em>) – The Q matrix used in RRQR reduction in finding the rank.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.row_swap_matrix">
<code class="descclassname">yroots.utils.</code><code class="descname">row_swap_matrix</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.row_swap_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearrange the rows of matrix so it is close to upper traingular.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>2D numpy array</em>) – The matrix whose rows need to be switched</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same matrix but with the rows changed so it is close to upper
triangular</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D numpy array</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">utils</span><span class="o">.</span><span class="n">row_swap_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]))</span>
<span class="go">array([[1, 2, 3, 4],</span>
<span class="go">       [0, 2, 0, 2],</span>
<span class="go">       [0, 1, 3, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.slice_bottom">
<code class="descclassname">yroots.utils.</code><code class="descname">slice_bottom</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.slice_bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the n-d slices needed to slice a matrix into the bottom corner of another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coeff</strong> (<em>numpy matrix.</em>) – The matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>slices</strong> – Each value of the list is a slice of the matrix in some dimension. It is exactly the size of the matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.slice_top">
<code class="descclassname">yroots.utils.</code><code class="descname">slice_top</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.slice_top" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the n-d slices needed to slice a matrix into the top corner of another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coeff</strong> (<em>numpy matrix.</em>) – The matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>slices</strong> – Each value of the list is a slice of the matrix in some dimension. It is exactly the size of the matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.sort_polys_by_degree">
<code class="descclassname">yroots.utils.</code><code class="descname">sort_polys_by_degree</code><span class="sig-paren">(</span><em>polys</em>, <em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.sort_polys_by_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the polynomials by their degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polys</strong> (<em>list.</em>) – A list of polynomials.</p></li>
<li><p><strong>ascending</strong> (<em>bool</em>) – Defaults to True. If True the polynomials are sorted in order of ascending degree. If False they
are sorted in order of descending degree.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sorted_polys</strong> – A list of the same polynomials, now sorted.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.sorted_polys_coeff">
<code class="descclassname">yroots.utils.</code><code class="descname">sorted_polys_coeff</code><span class="sig-paren">(</span><em>polys</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.sorted_polys_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the polynomials by how much bigger the leading coefficient is than
the rest of the coeff matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polys</strong> (<em>array-like</em>) – Contains polynomial objects to sort.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sorted_polys</strong> – The polynomial objects in order of lead coefficient to everything else
ratio.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.sorted_polys_monomial">
<code class="descclassname">yroots.utils.</code><code class="descname">sorted_polys_monomial</code><span class="sig-paren">(</span><em>polys</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.sorted_polys_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the polynomials by the number of monomials they have, the ones
with the least amount first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polys</strong> (<em>array-like</em><em>, </em><em>contains polynomial objects !!! Is it a list</em><em> or </em><em>could it be any iterable?</em>) – Polynomials to be sorted</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sorted_polys</strong> – Polynomials in order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yroots.utils.triangular_solve">
<code class="descclassname">yroots.utils.</code><code class="descname">triangular_solve</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#yroots.utils.triangular_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a matrix that is in row echelon form and reduces it into row reduced echelon form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>2D numpy array</em>) – The matrix of interest.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>matrix</strong> – The matrix is row reduced echelon form.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D numpy array</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">YRoots</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Home</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.subdivision">Subdivision</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.OneDimension">One Dimension</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.Multiplication">Multiplication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.IntervalChecks">Interval Checks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.MacaulayReduce">Macaulay Reduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.polynomial">Polynomial</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.polyroots">Polyroots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.LinearProjection">Linear Projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.ProjectiveSpace">Projective Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.Division">Division</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-yroots.utils">Utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index of Functions</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">YRoots</a></li>
      <li>Next: <a href="genindex.html" title="next chapter">Glossary of Methods</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, BYU Math.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/modules.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>