subdivision.subdivision_solve_nd:
    Checks to see if there's a bad approximation by
    checking if coeff is none (full_cheb_approximate
    return).
        return subdivision
    
    Checks to see if it can throw out any inteval
    If so,
        return zeros
    
    Trim coefficients

    Check if everything on the interval is linear
    by checking that the shape of the coefficients is 2.
    If so, solve in zeros.
        except singular matrix,
        determine whether there are no roots or
        infinitely many roots.

    If polish
        return polished zeros
    else
        return zeros

    If not everything is linear, check to see if something
    is linear by looking at the shape of each coefficient?
    If so subdivide with interval checks.
        If intervals are length 0, return zeros
        else pass in new good_degs and return subdivision_solve_nd

    Division variable cases: What do they do for
    multiplication? Additional subdivision?

    Get the polynomials as Multicheb polynomials
    Solve for zeros using (division)
    If not integers, run interval track data?
    Else increment divisor_var until you find a good
    direciton.
    
    ### Why check if zeros are integers?

    If the length of the intervals are zero, return 0
    else recursion with new good_degs

    =================================================================

    Base Case executes when
        1. Coef =/= None
            - Approximation is good
        2. Everything is linear
        3. Not a singular matrix
        4. Return polish or not polished

    Division executes (2 cases) when
        1. Coeff =/= None
            - Approximation is good
        2. *Nothing* is linear
        3.1.1 Not instance int (nothing went wrong)
        3.1.2 List of intervals is not len 0
        
        3.2.1 Is instance int (something went wrong)
        3.2.2 Find a good division direction (while)
        3.2.3 There exists a good division direction
            - Either throws out interval or recurses
        3.2.4 Solve in div direction

    =============================================================
    erik_develop update

    "Base Case" executes when
    This is basically using linear algebra to solve it.
        1.  Coef =/= None
                - Approximation is good
        2.  Everything is linear
        3.  Not a singular matrix
        4.  Return polish or not polished

    Multiplication Matrix executes when
        1.  Coeff =/= None
                - Approximation is good
        2.  *Nothing* is linear
        3.  Not instance int (nothing went wrong)
        4.  List of intervals is not len 0
    
    Subdivides when:
        1.  Bad approximation
        2.  Some (but not all) are linear
        3.  Nothing is linear and something goes
            wrong with multiplication/Macaulay

If it has the possibility of being linear (partially linear)
then subdivides until it's linear.

If nothing is linear but the approximation is good, then it 
uses the Macaulay method.