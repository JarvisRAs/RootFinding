import numpy as np
import itertools
import warnings
from TVB_Method.cheb_class import MultiCheb
from TVB_Method.TVB import TelenVanBarel
from TVB_Method.cheb_utils import get_var_list, TVBError, Term, match_size, match_poly_dimensions

'''
This module contains the tools necessary to find the points of the variety of the
ideal generated by a Groebner basis.
'''

def roots(polys, method = 'Groebner'):
    '''
    Finds the roots of the given list of polynomials.

    Parameters
    ----------
    polys : list of polynomial objects
        Polynomials to find the common roots of.
    method : string
        The root finding method to be used. Can be either 'Groebner',
        'Macaulay', or 'TVB'.
    returns
    -------
    list of numpy arrays
        the common roots of the polynomials
    '''
    polys = match_poly_dimensions(polys)

    m_f, var_dict = TVBMultMatrix(polys)

    # Get list of indexes of single variables and store vars that were not
    # in the vector space basis.
    dim = max(f.dim for f in polys)
    var_list = get_var_list(dim)
    var_indexes = [-1]*dim
    for i in range(len(var_list)):
        var = var_list[i] # x_i
        var_indexes[i] = var_dict[var]

    # Get left eigenvectors

    e = np.linalg.eig(m_f.T)
    eig = e[1]
    num_vectors = eig.shape[1]

    eig_vectors = [eig[:,i] for i in range(num_vectors)] # columns of eig
    roots = []
    for v in eig_vectors:
        if v[var_dict[tuple(0 for i in range(dim))]] == 0:
            continue
        root = np.zeros(dim, dtype=complex)
        # This will always work because var_indexes and root have the
        # same length - dim - and var_indexes has the variables in the
        # order they should be in the root
        for i in range(dim):
            x_i_pos = var_indexes[i]
            if x_i_pos != -1:
                root[i] = v[x_i_pos]/v[var_dict[tuple(0 for i in range(dim))]]
        roots.append(root)
        #roots.append(newton_polish(polys,root,niter=1000,tol=1e-10))
    return roots

def sortVB(VB):
    '''
    Sorts the Vector Basis into degrevlex order so the eigensolve is faster (in theory).

    Parameters
    ----------
    VB : numpy array
        Each row in VB is a term in the vector basis.

    Returns
    -------
    VB : numpy array
        The vector basis sorted so the lowest terms are at the top.
    '''
    VBList = list()
    for i in VB:
        VBList.append(Term(i))

    return VB[np.argsort(VBList)]

def TVBMultMatrix(polys):
    '''
    Finds the multiplication matrix using the reduced Macaulay matrix from the
    TVB method.

    Parameters
    ----------
    polys : array-like
        The polynomials to find the common zeros of

    Returns
    -------
    multiplicationMatrix : 2D numpy array
        The multiplication matrix for a random polynomial f
    var_dict : dictionary
        Maps each variable to its position in the vector space basis
    '''
    basisDict, VB, degree = TelenVanBarel(polys)

    VB = sortVB(VB)

    dim = max(f.dim for f in polys)

    # Get random polynomial f
    f = _random_poly(dim)[0]

    slices = list()
    for i in range(len(VB[0])):
        slices.append(VB.T[i])

    VBset = set()
    for mon in VB:
        VBset.add(tuple(mon))

    # Build multiplication matrix m_f
    mMatrix = np.zeros((len(VB), len(VB)))
    remainder = np.zeros([degree]*dim)

    for i in range(VB.shape[0]):
        f_coeff = f.mon_mult(VB[i], returnType = 'Matrix')
        for term in zip(*np.where(f_coeff != 0)):
            if term in VBset:
                remainder[term] += f_coeff[term]
            else:
                remainder[slices] -= f_coeff[term]*basisDict[term][slices]
        mMatrix[:,i] = remainder[slices]
        remainder[slices] = 0

    # Construct var_dict
    var_dict = {}
    for i in range(len(VB)):
        mon = VB[i]
        if np.sum(mon) == 1 or np.sum(mon) == 0:
            var_dict[tuple(mon)] = i

    return mMatrix, var_dict

def _random_poly(dim):
    '''
    Generates a random Chebyshev polynomial that has the form
    c_1x_1 + c_2x_2 + ... + c_nx_n where n = dim and each c_i is a randomly
    chosen integer between 0 and 1000.

    Parameters
    ----------
    dim : int
        Degree of polynomial to generate (?).

    Returns
    -------
    Polynomial
        Randomly generated Polynomial.
    '''
    _vars = get_var_list(dim)

    random_poly_shape = [2 for i in range(dim)]

    random_poly_coeff = np.zeros(tuple(random_poly_shape), dtype=int)
    for var in _vars:
        random_poly_coeff[var] = np.random.randint(1000)

    return MultiCheb(random_poly_coeff), _vars
